#include "GUI.h"
#include "ImageProcessor.h"
#include <sstream>
#include <iomanip>
#include <thread>
#include <future>

// 简化文件对话框 - 修复卡死问题
namespace SimpleFileDialog {
    std::string openFile(const char*) {
        std::string filename;
        std::cout << "\n请输入图像路径 (支持png,jpg,bmp格式): ";
        std::cout.flush();
        
        // 确保清空输入缓冲区
        std::cin.clear();
        if (std::cin.peek() == '\n') {
            std::cin.ignore();
        }
        
        std::getline(std::cin, filename);
        
        // 去除首尾空格
        if (!filename.empty()) {
            filename.erase(0, filename.find_first_not_of(" \t"));
            filename.erase(filename.find_last_not_of(" \t") + 1);
        }
        
        return filename;
    }
    
    std::string saveFile(const char*) {
        std::string filename;
        std::cout << "\n请输入保存路径 (例: output.png): ";
        std::cout.flush();
        
        std::cin.clear();
        if (std::cin.peek() == '\n') {
            std::cin.ignore();
        }
        
        std::getline(std::cin, filename);
        
        if (!filename.empty()) {
            filename.erase(0, filename.find_first_not_of(" \t"));
            filename.erase(filename.find_last_not_of(" \t") + 1);
        }
        
        return filename;
    }
}

// GuiUtils完整实现
namespace GuiUtils {
    ImVec4 getColorFromValue(float value, ColorMap colorMap) {
        value = std::max(0.0f, std::min(1.0f, value));
        
        switch (colorMap) {
            case ColorMap::GRAYSCALE:
                return ImVec4(value, value, value, 1.0f);
                
            case ColorMap::JET: {
                float r, g, b;
                if (value < 0.125f) {
                    r = 0.0f;
                    g = 0.0f;
                    b = 0.5f + 4.0f * value;
                } else if (value < 0.375f) {
                    r = 0.0f;
                    g = 4.0f * value - 0.5f;
                    b = 1.0f;
                } else if (value < 0.625f) {
                    r = 4.0f * value - 1.5f;
                    g = 1.0f;
                    b = -4.0f * value + 2.5f;
                } else if (value < 0.875f) {
                    r = 1.0f;
                    g = -4.0f * value + 3.5f;
                    b = 0.0f;
                } else {
                    r = -4.0f * value + 4.5f;
                    g = 0.0f;
                    b = 0.0f;
                }
                return ImVec4(r, g, b, 1.0f);
            }
            
            case ColorMap::HOT: {
                float r = std::min(1.0f, 3.0f * value);
                float g = std::min(1.0f, std::max(0.0f, 3.0f * value - 1.0f));
                float b = std::min(1.0f, std::max(0.0f, 3.0f * value - 2.0f));
                return ImVec4(r, g, b, 1.0f);
            }
            
            case ColorMap::COOL: {
                float r = value;
                float g = 1.0f - value;
                float b = 1.0f;
                return ImVec4(r, g, b, 1.0f);
            }
            
            case ColorMap::VIRIDIS: {
                // Viridis颜色映射的简化版本
                float r = 0.267004f + value * (0.993248f - 0.267004f) * 0.5f;
                float g = 0.004874f + value * (0.993248f - 0.004874f);
                float b = 0.329415f + value * (0.633929f - 0.329415f) * 2.0f;
                r = std::max(0.0f, std::min(1.0f, r));
                g = std::max(0.0f, std::min(1.0f, g));
                b = std::max(0.0f, std::min(1.0f, b));
                return ImVec4(r, g, b, 1.0f);
            }
            
            default:
                return ImVec4(value, value, value, 1.0f);
        }
    }

    void drawColorBar(ColorMap colorMap, float minVal, float maxVal, const ImVec2& size) {
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 canvasPos = ImGui::GetCursorScreenPos();
        
        // 绘制颜色条背景
        drawList->AddRectFilled(canvasPos, 
                               ImVec2(canvasPos.x + size.x, canvasPos.y + size.y),
                               IM_COL32(50, 50, 50, 255));
        
        // 绘制颜色渐变
        int numSteps = std::min(256, (int)size.y);
        float stepHeight = size.y / numSteps;
        
        for (int i = 0; i < numSteps; ++i) {
            float t = 1.0f - static_cast<float>(i) / (numSteps - 1); // 从上到下：高值到低值
            ImVec4 color = getColorFromValue(t, colorMap);
            ImU32 col32 = ImGui::ColorConvertFloat4ToU32(color);
            
            ImVec2 rectMin(canvasPos.x + 5, canvasPos.y + i * stepHeight);
            ImVec2 rectMax(canvasPos.x + size.x - 20, canvasPos.y + (i + 1) * stepHeight);
            
            drawList->AddRectFilled(rectMin, rectMax, col32);
        }
        
        // 绘制刻度线和标签
        int numTicks = 5;
        for (int i = 0; i <= numTicks; ++i) {
            float t = static_cast<float>(i) / numTicks;
            float y = canvasPos.y + t * size.y;
            float value = maxVal - t * (maxVal - minVal); // 从上到下：高值到低值
            
            // 刻度线
            drawList->AddLine(ImVec2(canvasPos.x + size.x - 20, y),
                             ImVec2(canvasPos.x + size.x - 15, y),
                             IM_COL32(255, 255, 255, 255), 1.0f);
            
            // 标签
            std::string label = formatNumber(value, 1);
            ImVec2 textSize = ImGui::CalcTextSize(label.c_str());
            drawList->AddText(ImVec2(canvasPos.x + size.x - 12, y - textSize.y * 0.5f),
                             IM_COL32(255, 255, 255, 255), label.c_str());
        }
        
        // 移动光标
        ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + size.y + 5));
    }

    std::string formatNumber(double value, int precision) {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(precision) << value;
        return oss.str();
    }

    void helpMarker(const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::IsItemHovered()) {
            ImGui::BeginTooltip();
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    }
}

GUI::GUI() : 
    window(nullptr),
    processor(std::make_unique<ImageProcessor>()),
    showMainWindow(true),
    showImageWindow(true),
    showFrequencyWindow(true),
    showControlWindow(true),
    showFilterWindow(false),
    showStatsWindow(false),
    showAboutWindow(false),
    originalImageTexture(0),
    frequencyMagnitudeTexture(0),
    frequencyPhaseTexture(0),
    filteredImageTexture(0),
    currentDisplayMode(DisplayMode::ORIGINAL_IMAGE),
    currentColorMap(ColorMap::GRAYSCALE),
    filterType(0),
    lowPassCutoff(0.5f),
    highPassCutoff(0.5f),
    bandPassLow(0.2f),
    bandPassHigh(0.8f),
    autoApplyFilter(false) {
        
    // 初始化统计数据
    originalStats = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    filteredStats = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
}

GUI::~GUI() {
    cleanup();
}

bool GUI::initialize() {
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return false;
    }
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    window = glfwCreateWindow(1400, 900, "FFT Image Processor - GUI", nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return false;
    }
    
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);
    
    if (glewInit() != GLEW_OK) {
        std::cerr << "Failed to initialize GLEW" << std::endl;
        return false;
    }
    
    setupCallbacks();
    initializeGUI();
    
    // 创建默认测试图像
    processor->createTestImage(256);
    processor->fft2D();
    updateImageTextures();
    
    std::cout << "GUI initialized successfully! Chinese font support enabled." << std::endl;
    
    return true;
}

void GUI::initializeGUI() {
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImPlot::CreateContext();
    
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    
    // 加载中文字体
    io.Fonts->AddFontFromFileTTF("third_party/imgui/misc/fonts/DroidSansFallback.ttf", 18.0f, NULL, io.Fonts->GetGlyphRangesChineseFull());
    
    // 如果没有中文字体文件，使用默认字体并添加中文字形范围
    if (io.Fonts->Fonts.empty()) {
        io.Fonts->AddFontDefault();
        io.Fonts->Build();
    }
    
    ImGui::StyleColorsDark();
    
    // 调整样式使其更现代化
    ImGuiStyle& style = ImGui::GetStyle();
    style.WindowRounding = 5.0f;
    style.FrameRounding = 3.0f;
    style.ScrollbarRounding = 3.0f;
    style.GrabRounding = 3.0f;
    style.WindowBorderSize = 1.0f;
    style.FrameBorderSize = 1.0f;
    
    // 调整颜色使其更加现代
    ImVec4* colors = style.Colors;
    colors[ImGuiCol_WindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 0.9f);
    colors[ImGuiCol_FrameBg] = ImVec4(0.2f, 0.2f, 0.2f, 0.5f);
    colors[ImGuiCol_Button] = ImVec4(0.3f, 0.3f, 0.8f, 0.8f);
    colors[ImGuiCol_ButtonHovered] = ImVec4(0.4f, 0.4f, 0.9f, 1.0f);
    colors[ImGuiCol_ButtonActive] = ImVec4(0.2f, 0.2f, 0.7f, 1.0f);
    
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 330 core");
}

void GUI::setupCallbacks() {
    glfwSetWindowUserPointer(window, this);
    glfwSetDropCallback(window, dropCallback);
    glfwSetKeyCallback(window, keyCallback);
}

void GUI::run() {
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        
        drawMainMenuBar();
        
        if (showImageWindow) drawImageWindow();
        if (showFrequencyWindow) drawFrequencyWindow();
        if (showControlWindow) drawControlWindow();
        if (showFilterWindow) drawFilterWindow();
        if (showStatsWindow) drawStatsWindow();
        if (showAboutWindow) drawAboutWindow();
        
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.45f, 0.55f, 0.60f, 1.00f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        
        glfwSwapBuffers(window);
    }
}

void GUI::drawMainMenuBar() {
    if (ImGui::BeginMainMenuBar()) {
        if (ImGui::BeginMenu("文件")) {
            if (ImGui::MenuItem("打开图像", "Ctrl+O")) {
                // 使用异步方式避免卡死
                std::thread([this]() {
                    this->openImageFile();
                }).detach();
            }
            if (ImGui::MenuItem("创建测试图像", "Ctrl+T")) {
                createTestImage();
            }
            ImGui::Separator();
            if (ImGui::MenuItem("保存图像", "Ctrl+S", false, processor->getWidth() > 0)) {
                std::thread([this]() {
                    this->saveCurrentImage();
                }).detach();
            }
            if (ImGui::MenuItem("另存为...", "Ctrl+Shift+S", false, processor->getWidth() > 0)) {
                std::thread([this]() {
                    this->saveImageAs();
                }).detach();
            }
            ImGui::Separator();
            if (ImGui::MenuItem("退出", "Alt+F4")) {
                glfwSetWindowShouldClose(window, GLFW_TRUE);
            }
            ImGui::EndMenu();
        }
        
        if (ImGui::BeginMenu("视图")) {
            ImGui::MenuItem("图像窗口", nullptr, &showImageWindow);
            ImGui::MenuItem("频域窗口", nullptr, &showFrequencyWindow);
            ImGui::MenuItem("控制面板", nullptr, &showControlWindow);
            ImGui::MenuItem("滤波器", nullptr, &showFilterWindow);
            ImGui::MenuItem("统计信息", nullptr, &showStatsWindow);
            ImGui::EndMenu();
        }
        
        if (ImGui::BeginMenu("工具")) {
            if (ImGui::MenuItem("重置滤波器")) {
                resetFilter();
            }
            if (ImGui::MenuItem("执行FFT", nullptr, false, processor->getWidth() > 0)) {
                processor->fft2D();
                updateImageTextures();
            }
            ImGui::EndMenu();
        }
        
        if (ImGui::BeginMenu("帮助")) {
            ImGui::MenuItem("关于", nullptr, &showAboutWindow);
            ImGui::EndMenu();
        }
        
        ImGui::EndMainMenuBar();
    }
}

void GUI::drawImageWindow() {
    ImGui::Begin("图像显示", &showImageWindow, ImGuiWindowFlags_MenuBar);
    
    if (ImGui::BeginMenuBar()) {
        if (ImGui::BeginMenu("显示模式")) {
            if (ImGui::MenuItem("原始图像", nullptr, currentDisplayMode == DisplayMode::ORIGINAL_IMAGE)) {
                currentDisplayMode = DisplayMode::ORIGINAL_IMAGE;
            }
            if (ImGui::MenuItem("频域幅度", nullptr, currentDisplayMode == DisplayMode::FREQUENCY_MAGNITUDE)) {
                currentDisplayMode = DisplayMode::FREQUENCY_MAGNITUDE;
            }
            if (ImGui::MenuItem("频域相位", nullptr, currentDisplayMode == DisplayMode::FREQUENCY_PHASE)) {
                currentDisplayMode = DisplayMode::FREQUENCY_PHASE;
            }
            if (ImGui::MenuItem("滤波后图像", nullptr, currentDisplayMode == DisplayMode::FILTERED_IMAGE)) {
                currentDisplayMode = DisplayMode::FILTERED_IMAGE;
            }
            if (ImGui::MenuItem("对比视图", nullptr, currentDisplayMode == DisplayMode::COMPARISON_VIEW)) {
                currentDisplayMode = DisplayMode::COMPARISON_VIEW;
            }
            ImGui::EndMenu();
        }
        
        if (ImGui::BeginMenu("颜色映射")) {
            if (ImGui::MenuItem("灰度", nullptr, currentColorMap == ColorMap::GRAYSCALE)) {
                currentColorMap = ColorMap::GRAYSCALE;
                updateImageTextures();
            }
            if (ImGui::MenuItem("Jet", nullptr, currentColorMap == ColorMap::JET)) {
                currentColorMap = ColorMap::JET;
                updateImageTextures();
            }
            if (ImGui::MenuItem("热度图", nullptr, currentColorMap == ColorMap::HOT)) {
                currentColorMap = ColorMap::HOT;
                updateImageTextures();
            }
            if (ImGui::MenuItem("冷色图", nullptr, currentColorMap == ColorMap::COOL)) {
                currentColorMap = ColorMap::COOL;
                updateImageTextures();
            }
            if (ImGui::MenuItem("Viridis", nullptr, currentColorMap == ColorMap::VIRIDIS)) {
                currentColorMap = ColorMap::VIRIDIS;
                updateImageTextures();
            }
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }
    
    if (processor->getWidth() > 0) {
        ImVec2 contentRegion = ImGui::GetContentRegionAvail();
        
        switch (currentDisplayMode) {
            case DisplayMode::ORIGINAL_IMAGE:
                drawImageWithLegend(originalImageTexture, processor->getWidth(), 
                                  processor->getHeight(), "原始图像", originalStats);
                break;
                
            case DisplayMode::FREQUENCY_MAGNITUDE:
                drawImageWithLegend(frequencyMagnitudeTexture, processor->getWidth(), 
                                  processor->getHeight(), "频域幅度", originalStats);
                break;
                
            case DisplayMode::FREQUENCY_PHASE:
                drawImageWithLegend(frequencyPhaseTexture, processor->getWidth(), 
                                  processor->getHeight(), "频域相位", originalStats);
                break;
                
            case DisplayMode::FILTERED_IMAGE:
                drawImageWithLegend(filteredImageTexture, processor->getWidth(), 
                                  processor->getHeight(), "滤波后图像", filteredStats);
                break;
                
            case DisplayMode::COMPARISON_VIEW:
                // 绘制对比视图
                ImVec2 imageSize(contentRegion.x / 2 - 10, contentRegion.y);
                
                ImGui::BeginChild("Original", ImVec2(imageSize.x, 0), true);
                drawImageWithLegend(originalImageTexture, processor->getWidth(), 
                                  processor->getHeight(), "原始图像", originalStats);
                ImGui::EndChild();
                
                ImGui::SameLine();
                
                ImGui::BeginChild("Filtered", ImVec2(imageSize.x, 0), true);
                drawImageWithLegend(filteredImageTexture, processor->getWidth(), 
                                  processor->getHeight(), "滤波后图像", filteredStats);
                ImGui::EndChild();
                break;
        }
    } else {
        ImGui::Text("没有加载图像");
        ImGui::Text("请从文件菜单加载图像或创建测试图像");
        ImGui::Spacing();
        if (ImGui::Button("创建测试图像")) {
            createTestImage();
        }
    }
    
    ImGui::End();
}

void GUI::drawImageWithLegend(GLuint texture, int width, int height, 
                            const std::string& title, const ImageStats& stats) {
    ImVec2 contentRegion = ImGui::GetContentRegionAvail();
    
    // 计算图像显示尺寸（保持宽高比）
    float aspectRatio = static_cast<float>(width) / static_cast<float>(height);
    ImVec2 imageSize;
    
    if (contentRegion.x / aspectRatio <= contentRegion.y - 120) {
        imageSize.x = contentRegion.x - 80;
        imageSize.y = imageSize.x / aspectRatio;
    } else {
        imageSize.y = contentRegion.y - 120;
        imageSize.x = imageSize.y * aspectRatio;
    }
    
    // 确保最小尺寸
    imageSize.x = std::max(imageSize.x, 100.0f);
    imageSize.y = std::max(imageSize.y, 100.0f);
    
    // 绘制标题
    ImGui::Text("%s (%dx%d)", title.c_str(), width, height);
    ImGui::Separator();
    
    if (texture != 0) {
        // 绘制图像
        ImGui::Image(reinterpret_cast<void*>(texture), imageSize);
        
        // 在图像旁边绘制颜色条
        ImGui::SameLine();
        ImVec2 colorBarSize(60, imageSize.y);
        GuiUtils::drawColorBar(currentColorMap, stats.minValue, stats.maxValue, colorBarSize);
    } else {
        // 如果纹理无效，显示占位符
        ImGui::Button("图像加载中...", imageSize);
    }
    
    // 绘制图像统计信息
    ImGui::Separator();
    ImGui::Text("统计信息:");
    ImGui::Columns(2, "stats", false);
    
    ImGui::Text("最小值: %s", GuiUtils::formatNumber(stats.minValue, 2).c_str());
    ImGui::NextColumn();
    ImGui::Text("最大值: %s", GuiUtils::formatNumber(stats.maxValue, 2).c_str());
    ImGui::NextColumn();
    
    ImGui::Text("平均值: %s", GuiUtils::formatNumber(stats.meanValue, 2).c_str());
    ImGui::NextColumn();
    ImGui::Text("标准差: %s", GuiUtils::formatNumber(stats.stdValue, 2).c_str());
    ImGui::NextColumn();
    
    if (currentDisplayMode == DisplayMode::FILTERED_IMAGE && filteredStats.mse > 0) {
        ImGui::Text("MSE: %s", GuiUtils::formatNumber(filteredStats.mse, 4).c_str());
        ImGui::NextColumn();
        ImGui::Text("PSNR: %s dB", GuiUtils::formatNumber(filteredStats.psnr, 2).c_str());
        ImGui::NextColumn();
        ImGui::Text("SSIM: %s", GuiUtils::formatNumber(filteredStats.ssim, 4).c_str());
        ImGui::NextColumn();
        ImGui::Text(""); // 空列
    }
    
    ImGui::Columns(1);
}

// 继续实现其他方法...
void GUI::drawFrequencyWindow() {
    ImGui::Begin("频域分析", &showFrequencyWindow);
    
    if (processor->getWidth() > 0) {
        ImGui::Text("频域分析 - 图像尺寸: %dx%d", processor->getWidth(), processor->getHeight());
        ImGui::Separator();
        
        drawFrequencyPlot();
        
        ImGui::Separator();
        
        if (ImGui::BeginTabBar("FrequencyTabs")) {
            if (ImGui::BeginTabItem("幅度分布")) {
                drawHistogram(processor->getGrayImage(), "像素值分布");
                ImGui::EndTabItem();
            }
            
            if (ImGui::BeginTabItem("频域信息")) {
                ImGui::Text("FFT变换已完成");
                ImGui::Text("频域数据可用于滤波处理");
                
                if (ImGui::Button("重新计算FFT")) {
                    processor->fft2D();
                    updateImageTextures();
                }
                ImGui::EndTabItem();
            }
            
            ImGui::EndTabBar();
        }
    } else {
        ImGui::Text("请先加载图像以查看频域分析");
        if (ImGui::Button("创建测试图像")) {
            createTestImage();
        }
    }
    
    ImGui::End();
}

void GUI::drawControlWindow() {
    ImGui::Begin("控制面板", &showControlWindow);
    
    ImGui::Text("图像信息:");
    ImGui::Separator();
    
    if (processor->getWidth() > 0) {
        ImGui::Text("尺寸: %dx%d", processor->getWidth(), processor->getHeight());
        ImGui::Text("通道数: %d", processor->getOriginalChannels());
        ImGui::Text("文件: %s", currentImagePath.empty() ? "测试图像" : currentImagePath.c_str());
        
        ImGui::Spacing();
        ImGui::Text("像素总数: %d", processor->getWidth() * processor->getHeight());
        
        if (processor->getGrayImage().size() > 0) {
            ImGui::Text("数据状态: 已加载");
        }
    } else {
        ImGui::Text("未加载图像");
    }
    
    ImGui::Separator();
    ImGui::Text("显示控制:");
    
    if (ImGui::Button("重置视图", ImVec2(-1, 0))) {
        currentDisplayMode = DisplayMode::ORIGINAL_IMAGE;
        currentColorMap = ColorMap::GRAYSCALE;
        updateImageTextures();
    }
    
    ImGui::Separator();
    ImGui::Text("快速操作:");
    
    if (ImGui::Button("执行FFT", ImVec2(-1, 0))) {
        if (processor->getWidth() > 0) {
            processor->fft2D();
            updateImageTextures();
            ImGui::OpenPopup("FFT完成");
        }
    }
    
    if (ImGui::Button("应用滤波器", ImVec2(-1, 0))) {
        applyCurrentFilter();
    }
    
    if (ImGui::Button("重置滤波器", ImVec2(-1, 0))) {
        resetFilter();
    }
    
    // 弹出提示
    if (ImGui::BeginPopupModal("FFT完成", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("FFT变换已完成！");
        ImGui::Separator();
        if (ImGui::Button("确定", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
    
    ImGui::End();
}

void GUI::drawFilterWindow() {
    ImGui::Begin("滤波器设置", &showFilterWindow);
    
    ImGui::Text("滤波器类型:");
    bool typeChanged = false;
    
    if (ImGui::RadioButton("低通滤波", &filterType, 0)) typeChanged = true;
    ImGui::SameLine();
    GuiUtils::helpMarker("保留低频成分，去除高频噪声");
    
    if (ImGui::RadioButton("高通滤波", &filterType, 1)) typeChanged = true;
    ImGui::SameLine();
    GuiUtils::helpMarker("保留高频成分，增强边缘细节");
    
    if (ImGui::RadioButton("带通滤波", &filterType, 2)) typeChanged = true;
    ImGui::SameLine();
    GuiUtils::helpMarker("只保留特定频率范围的成分");
    
    ImGui::Separator();
    
    bool paramChanged = false;
    
    switch (filterType) {
        case 0: // 低通
            if (ImGui::SliderFloat("截止频率", &lowPassCutoff, 0.01f, 1.0f, "%.3f")) {
                paramChanged = true;
            }
            ImGui::Text("当前设置: 保留 %.1f%% 的低频成分", lowPassCutoff * 100);
            break;
            
        case 1: // 高通  
            if (ImGui::SliderFloat("截止频率", &highPassCutoff, 0.01f, 1.0f, "%.3f")) {
                paramChanged = true;
            }
            ImGui::Text("当前设置: 移除 %.1f%% 的低频成分", highPassCutoff * 100);
            break;
            
        case 2: // 带通
            if (ImGui::SliderFloat("低截止频率", &bandPassLow, 0.01f, 0.99f, "%.3f")) {
                paramChanged = true;
            }
            if (ImGui::SliderFloat("高截止频率", &bandPassHigh, 0.02f, 1.0f, "%.3f")) {
                paramChanged = true;
            }
            
            if (bandPassLow >= bandPassHigh) {
                ImGui::TextColored(ImVec4(1, 0, 0, 1), "警告: 低截止频率应小于高截止频率");
                if (bandPassLow >= bandPassHigh) {
                    bandPassHigh = bandPassLow + 0.01f;
                }
            } else {
                ImGui::Text("频率范围: %.1f%% - %.1f%%", bandPassLow * 100, bandPassHigh * 100);
            }
            break;
    }
    
    if (typeChanged || paramChanged) {
        onFilterParameterChanged();
    }
    
    ImGui::Separator();
    
    if (ImGui::Checkbox("自动应用", &autoApplyFilter)) {
        if (autoApplyFilter) {
            applyCurrentFilter();
        }
    }
    ImGui::SameLine();
    GuiUtils::helpMarker("启用后，参数改变时自动应用滤波器");
    
    if (ImGui::Button("手动应用", ImVec2(-1, 0))) {
        applyCurrentFilter();
    }
    
    if (ImGui::Button("重置参数", ImVec2(-1, 0))) {
        resetFilter();
    }
    
    ImGui::Separator();
    ImGui::Text("预览效果:");
    ImGui::Text("原图 → 滤波器 → 结果图");
    ImGui::Text("可在图像窗口中切换查看效果");
    
    ImGui::End();
}

void GUI::drawStatsWindow() {
    ImGui::Begin("统计信息", &showStatsWindow);
    
    if (processor->getWidth() > 0) {
        ImGui::Text("原始图像统计:");
        ImGui::Separator();
        
        ImGui::Columns(2, "original_stats", false);
        ImGui::Text("图像尺寸");
        ImGui::NextColumn();
        ImGui::Text("%dx%d", processor->getWidth(), processor->getHeight());
        ImGui::NextColumn();
        
        ImGui::Text("最小值");
        ImGui::NextColumn();
        ImGui::Text("%.3f", originalStats.minValue);
        ImGui::NextColumn();
        
        ImGui::Text("最大值");
        ImGui::NextColumn();
        ImGui::Text("%.3f", originalStats.maxValue);
        ImGui::NextColumn();
        
        ImGui::Text("平均值");
        ImGui::NextColumn();
        ImGui::Text("%.3f", originalStats.meanValue);
        ImGui::NextColumn();
        
        ImGui::Text("标准差");
        ImGui::NextColumn();
        ImGui::Text("%.3f", originalStats.stdValue);
        ImGui::NextColumn();
        
        ImGui::Columns(1);
        
        ImGui::Spacing();
        
        // 原始图像直方图
        ImGui::Text("像素值分布:");
        drawHistogram(processor->getGrayImage(), "原始图像直方图");
        
        ImGui::Spacing();
        
        if (filteredImageTexture && filteredStats.mse >= 0) {
            ImGui::Text("滤波后图像统计:");
            ImGui::Separator();
            
            ImGui::Columns(2, "filtered_stats", false);
            
            ImGui::Text("MSE (均方误差)");
            ImGui::NextColumn();
            ImGui::Text("%.6f", filteredStats.mse);
            ImGui::NextColumn();
            
            ImGui::Text("PSNR (峰值信噪比)");
            ImGui::NextColumn();
            ImGui::Text("%.2f dB", filteredStats.psnr);
            ImGui::NextColumn();
            
            ImGui::Text("SSIM (结构相似性)");
            ImGui::NextColumn();
            ImGui::Text("%.4f", filteredStats.ssim);
            ImGui::NextColumn();
            
            ImGui::Text("最小值");
            ImGui::NextColumn();
            ImGui::Text("%.3f", filteredStats.minValue);
            ImGui::NextColumn();
            
            ImGui::Text("最大值");
            ImGui::NextColumn();
            ImGui::Text("%.3f", filteredStats.maxValue);
            ImGui::NextColumn();
            
            ImGui::Text("平均值");
            ImGui::NextColumn();
            ImGui::Text("%.3f", filteredStats.meanValue);
            ImGui::NextColumn();
            
            ImGui::Text("标准差");
            ImGui::NextColumn();
            ImGui::Text("%.3f", filteredStats.stdValue);
            ImGui::NextColumn();
            
            ImGui::Columns(1);
            
            // 质量评估指标解释
            ImGui::Spacing();
            ImGui::Text("质量指标说明:");
            ImGui::BulletText("MSE: 均方误差，越小越好 (0表示完全相同)");
            ImGui::BulletText("PSNR: 峰值信噪比，越大越好 (通常>30dB为良好)");
            ImGui::BulletText("SSIM: 结构相似性，越接近1越好 (1表示完全相同)");
        }
    } else {
        ImGui::Text("请先加载图像");
        if (ImGui::Button("创建测试图像")) {
            createTestImage();
        }
    }
    
    ImGui::End();
}

void GUI::drawAboutWindow() {
    ImGui::Begin("关于", &showAboutWindow, ImGuiWindowFlags_AlwaysAutoResize);
    
    ImGui::Text("FFT 图像处理器 - GUI版本");
    ImGui::Text("版本: 2.0.0");
    ImGui::Separator();
    
    ImGui::Text("功能特性:");
    ImGui::BulletText("2D 快速傅里叶变换 (FFT)");
    ImGui::BulletText("多种数字滤波器 (低通/高通/带通)");
    ImGui::BulletText("实时参数调整和预览");
    ImGui::BulletText("图像质量评估 (MSE/PSNR/SSIM)");
    ImGui::BulletText("多种颜色映射显示");
    ImGui::BulletText("完整的统计分析");
    
    ImGui::Spacing();
    ImGui::Text("技术栈:");
    ImGui::BulletText("ImGui - 现代化用户界面");
    ImGui::BulletText("ImPlot - 专业数据可视化");
    ImGui::BulletText("OpenGL - 高性能图形渲染");
    ImGui::BulletText("GLFW - 跨平台窗口管理");
    ImGui::BulletText("STB - 轻量级图像处理");
    
    ImGui::Spacing();
    ImGui::Text("快捷键:");
    ImGui::BulletText("Ctrl+O: 打开图像文件");
    ImGui::BulletText("Ctrl+S: 保存当前图像");
    ImGui::BulletText("Ctrl+T: 创建测试图像");
    ImGui::BulletText("拖拽: 直接拖拽图像文件到窗口");
    
    ImGui::Spacing();
    ImGui::Text("使用提示:");
    ImGui::BulletText("支持 PNG, JPG, BMP 等常见格式");
    ImGui::BulletText("图像会自动调整为2的幂次尺寸");
    ImGui::BulletText("可实时调整滤波器参数查看效果");
    ImGui::BulletText("所有窗口都可独立移动和调整");
    
    ImGui::Spacing();
    if (ImGui::Button("关闭", ImVec2(120, 0))) {
        showAboutWindow = false;
    }
    
    ImGui::End();
}

void GUI::drawFrequencyPlot() {
    if (processor->getWidth() == 0) return;
    
    // 创建频谱数据用于绘制
    const auto& freqDomain = processor->getFrequencyDomain();
    int width = processor->getWidth();
    int height = processor->getHeight();
    
    if (freqDomain.empty() || freqDomain.size() != height) {
        ImGui::Text("频域数据不可用，请先执行FFT");
        return;
    }
    
    // 计算中心线的频谱（水平和垂直）
    std::vector<float> freqX, freqY;
    std::vector<float> magnitudeX, magnitudeY;
    
    // 水平中心线频谱
    int centerY = height / 2;
    for (int x = 0; x < width; ++x) {
        freqX.push_back(static_cast<float>(x - width/2));
        double mag = freqDomain[centerY][x].magnitude();
        magnitudeX.push_back(static_cast<float>(std::log(1.0 + mag)));
    }
    
    // 垂直中心线频谱
    int centerX = width / 2;
    for (int y = 0; y < height; ++y) {
        freqY.push_back(static_cast<float>(y - height/2));
        double mag = freqDomain[y][centerX].magnitude();
        magnitudeY.push_back(static_cast<float>(std::log(1.0 + mag)));
    }
    
    // 绘制频谱图
    if (ImPlot::BeginPlot("频域分析 (中心切片)", ImVec2(-1, 300))) {
        ImPlot::SetupAxes("频率位置", "幅度 (对数)");
        
        if (!magnitudeX.empty()) {
            ImPlot::PlotLine("水平频谱", freqX.data(), magnitudeX.data(), width);
        }
        if (!magnitudeY.empty()) {
            ImPlot::PlotLine("垂直频谱", freqY.data(), magnitudeY.data(), height);
        }
        
        ImPlot::EndPlot();
    }
}

void GUI::drawHistogram(const std::vector<std::vector<double>>& image, const std::string& title) {
    if (image.empty()) return;
    
    // 计算直方图
    const int numBins = 64; // 减少bin数量提高性能
    std::vector<float> bins(numBins, 0.0f);
    std::vector<float> binCenters(numBins);
    
    // 找到数据范围
    double minVal = image[0][0];
    double maxVal = image[0][0];
    for (const auto& row : image) {
        for (double val : row) {
            minVal = std::min(minVal, val);
            maxVal = std::max(maxVal, val);
        }
    }
    
    if (maxVal == minVal) {
        ImGui::Text("图像数据无变化");
        return;
    }
    
    // 计算bin范围
    double binWidth = (maxVal - minVal) / numBins;
    for (int i = 0; i < numBins; ++i) {
        binCenters[i] = minVal + (i + 0.5) * binWidth;
    }
    
    // 统计像素值
    for (const auto& row : image) {
        for (double val : row) {
            int binIndex = static_cast<int>((val - minVal) / binWidth);
            binIndex = std::max(0, std::min(numBins - 1, binIndex));
            bins[binIndex] += 1.0f;
        }
    }
    
    // 绘制直方图
    if (ImPlot::BeginPlot(title.c_str(), ImVec2(-1, 200))) {
        ImPlot::SetupAxes("像素值", "频数");
        ImPlot::PlotBars("分布", binCenters.data(), bins.data(), numBins, binWidth * 0.8);
        ImPlot::EndPlot();
    }
}

// 实现纹理更新方法
void GUI::updateImageTextures() {
    if (processor->getWidth() == 0) return;
    
    // 计算原始图像统计
    calculateImageStats(processor->getGrayImage(), originalStats);
    
    // 创建或更新原始图像纹理
    originalImageTexture = createTextureFromImage(processor->getGrayImage(), 
                                                 processor->getWidth(), 
                                                 processor->getHeight(), 
                                                 ColorMap::GRAYSCALE);
    
    // 创建频域幅度和相位图像
    const auto& freqDomain = processor->getFrequencyDomain();
    if (!freqDomain.empty()) {
        std::vector<std::vector<double>> magnitudeImage(processor->getHeight(), 
                                                        std::vector<double>(processor->getWidth()));
        std::vector<std::vector<double>> phaseImage(processor->getHeight(), 
                                                   std::vector<double>(processor->getWidth()));
        
        for (int y = 0; y < processor->getHeight(); ++y) {
            for (int x = 0; x < processor->getWidth(); ++x) {
                magnitudeImage[y][x] = std::log(1.0 + freqDomain[y][x].magnitude());
                phaseImage[y][x] = freqDomain[y][x].phase() + M_PI; // 偏移到0-2π范围
            }
        }
        
        frequencyMagnitudeTexture = createTextureFromImage(magnitudeImage, 
                                                          processor->getWidth(), 
                                                          processor->getHeight(), 
                                                          currentColorMap);
        
        frequencyPhaseTexture = createTextureFromImage(phaseImage, 
                                                      processor->getWidth(), 
                                                      processor->getHeight(), 
                                                      currentColorMap);
    }
    
    // 应用当前滤波器
    applyCurrentFilter();
}

GLuint GUI::createTextureFromImage(const std::vector<std::vector<double>>& image, 
                                   int width, int height, ColorMap colorMap) {
    if (image.empty() || width <= 0 || height <= 0) {
        return 0;
    }
    
    // 找到最大值和最小值用于归一化
    double minVal = image[0][0];
    double maxVal = image[0][0];
    
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (y < image.size() && x < image[y].size()) {
                minVal = std::min(minVal, image[y][x]);
                maxVal = std::max(maxVal, image[y][x]);
            }
        }
    }
    
    // 创建RGBA颜色数据
    std::vector<unsigned char> colorData(width * height * 4);
    
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            double value = 0.0;
            if (y < image.size() && x < image[y].size()) {
                value = image[y][x];
            }
            
            // 归一化值
            double normalized = (maxVal != minVal) ? (value - minVal) / (maxVal - minVal) : 0.0;
            ImVec4 color = GuiUtils::getColorFromValue(normalized, colorMap);
            
            int idx = (y * width + x) * 4;
            colorData[idx + 0] = static_cast<unsigned char>(color.x * 255);
            colorData[idx + 1] = static_cast<unsigned char>(color.y * 255);
            colorData[idx + 2] = static_cast<unsigned char>(color.z * 255);
            colorData[idx + 3] = 255; // Alpha
        }
    }
    
    // 创建OpenGL纹理
    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_2D, textureID);
    
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, colorData.data());
    
    glBindTexture(GL_TEXTURE_2D, 0);
    
    return textureID;
}

void GUI::calculateImageStats(const std::vector<std::vector<double>>& image, ImageStats& stats) {
    if (image.empty() || image[0].empty()) {
        stats = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
        return;
    }
    
    int height = image.size();
    int width = image[0].size();
    
    stats.minValue = image[0][0];
    stats.maxValue = image[0][0];
    stats.meanValue = 0.0;
    
    // 计算最小值、最大值和平均值
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            double val = image[y][x];
            stats.minValue = std::min(stats.minValue, val);
            stats.maxValue = std::max(stats.maxValue, val);
            stats.meanValue += val;
        }
    }
    stats.meanValue /= (width * height);
    
    // 计算标准差
    stats.stdValue = 0.0;
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            double diff = image[y][x] - stats.meanValue;
            stats.stdValue += diff * diff;
        }
    }
    stats.stdValue = std::sqrt(stats.stdValue / (width * height));
}

void GUI::applyCurrentFilter() {
    if (processor->getWidth() == 0) return;
    
    std::vector<std::vector<Complex>> filteredFreq;
    
    switch (filterType) {
        case 0: // 低通
            filteredFreq = processor->lowPassFilter(lowPassCutoff);
            break;
        case 1: // 高通
            filteredFreq = processor->highPassFilter(highPassCutoff);
            break;
        case 2: // 带通
            if (bandPassLow < bandPassHigh) {
                filteredFreq = processor->bandPassFilter(bandPassLow, bandPassHigh);
            } else {
                filteredFreq = processor->getFrequencyDomain();
            }
            break;
        default:
            filteredFreq = processor->getFrequencyDomain();
            break;
    }
    
    // 重建图像
    auto filteredImage = processor->ifft2D(filteredFreq);
    
    // 创建滤波后图像纹理
    if (filteredImageTexture) {
        glDeleteTextures(1, &filteredImageTexture);
    }
    filteredImageTexture = createTextureFromImage(filteredImage, 
                                                 processor->getWidth(), 
                                                 processor->getHeight(), 
                                                 ColorMap::GRAYSCALE);
    
    // 计算滤波后图像统计信息
    calculateImageStats(filteredImage, filteredStats);
    
    // 计算质量指标
    if (!processor->getGrayImage().empty()) {
        filteredStats.mse = processor->calculateMSE(processor->getGrayImage(), filteredImage);
        filteredStats.psnr = processor->calculatePSNR(filteredStats.mse);
        filteredStats.ssim = processor->calculateSSIM(processor->getGrayImage(), filteredImage);
    }
}

// 其他必要方法的实现
void GUI::cleanup() {
    if (originalImageTexture) glDeleteTextures(1, &originalImageTexture);
    if (frequencyMagnitudeTexture) glDeleteTextures(1, &frequencyMagnitudeTexture);
    if (frequencyPhaseTexture) glDeleteTextures(1, &frequencyPhaseTexture);
    if (filteredImageTexture) glDeleteTextures(1, &filteredImageTexture);
    
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImPlot::DestroyContext();
    ImGui::DestroyContext();
    
    if (window) {
        glfwDestroyWindow(window);
    }
    glfwTerminate();
}

void GUI::dropCallback(GLFWwindow* window, int count, const char** paths) {
    GUI* gui = static_cast<GUI*>(glfwGetWindowUserPointer(window));
    if (gui && count > 0) {
        gui->currentImagePath = paths[0];
        std::cout << "拖拽文件: " << paths[0] << std::endl;
        if (gui->processor->loadImage(paths[0])) {
            gui->processor->fft2D();
            gui->updateImageTextures();
            std::cout << "图像加载成功！" << std::endl;
        } else {
            std::cout << "图像加载失败！" << std::endl;
        }
    }
}

void GUI::keyCallback(GLFWwindow* window, int key, int, int action, int mods) {
    GUI* gui = static_cast<GUI*>(glfwGetWindowUserPointer(window));
    if (gui && action == GLFW_PRESS && (mods & GLFW_MOD_CONTROL)) {
        switch (key) {
            case GLFW_KEY_O:
                std::thread([gui]() { gui->openImageFile(); }).detach();
                break;
            case GLFW_KEY_S:
                if (mods & GLFW_MOD_SHIFT) {
                    std::thread([gui]() { gui->saveImageAs(); }).detach();
                } else {
                    std::thread([gui]() { gui->saveCurrentImage(); }).detach();
                }
                break;
            case GLFW_KEY_T:
                gui->createTestImage();
                break;
        }
    }
}

bool GUI::openImageFile() {
    std::string filename = SimpleFileDialog::openFile("");
    if (!filename.empty()) {
        currentImagePath = filename;
        if (processor->loadImage(filename)) {
            processor->fft2D();
            updateImageTextures();
            std::cout << "图像加载成功: " << filename << std::endl;
            return true;
        } else {
            std::cout << "图像加载失败: " << filename << std::endl;
        }
    }
    return false;
}

bool GUI::saveImageAs() {
    std::string filename = SimpleFileDialog::saveFile("");
    if (!filename.empty()) {
        lastSavePath = filename;
        return saveCurrentImage();
    }
    return false;
}

bool GUI::saveCurrentImage() {
    if (processor->getWidth() == 0) {
        std::cout << "没有图像可保存" << std::endl;
        return false;
    }
    
    if (lastSavePath.empty()) {
        return saveImageAs();
    }
    
    // 根据当前显示模式保存相应的图像
    std::vector<std::vector<double>> imageToSave;
    
    switch (currentDisplayMode) {
        case DisplayMode::ORIGINAL_IMAGE:
            imageToSave = processor->getGrayImage();
            break;
        case DisplayMode::FILTERED_IMAGE:
            // 获取当前滤波后的图像
            {
                std::vector<std::vector<Complex>> filteredFreq;
                switch (filterType) {
                    case 0: filteredFreq = processor->lowPassFilter(lowPassCutoff); break;
                    case 1: filteredFreq = processor->highPassFilter(highPassCutoff); break;
                    case 2: filteredFreq = processor->bandPassFilter(bandPassLow, bandPassHigh); break;
                    default: filteredFreq = processor->getFrequencyDomain(); break;
                }
                imageToSave = processor->ifft2D(filteredFreq);
            }
            break;
        default:
            imageToSave = processor->getGrayImage();
            break;
    }
    
    bool success = processor->saveImage(lastSavePath, imageToSave);
    if (success) {
        std::cout << "图像保存成功: " << lastSavePath << std::endl;
    } else {
        std::cout << "图像保存失败: " << lastSavePath << std::endl;
    }
    return success;
}

void GUI::createTestImage() {
    processor->createTestImage(256);
    processor->fft2D();
    updateImageTextures();
    currentImagePath = "";
    std::cout << "测试图像创建完成" << std::endl;
}

void GUI::resetFilter() {
    filterType = 0;
    lowPassCutoff = 0.5f;
    highPassCutoff = 0.5f;
    bandPassLow = 0.2f;
    bandPassHigh = 0.8f;
    applyCurrentFilter();
}

void GUI::onFilterParameterChanged() {
    if (autoApplyFilter && processor->getWidth() > 0) {
        applyCurrentFilter();
    }
}